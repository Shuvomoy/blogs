<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/blogs/libs/katex/katex.min.css"> <link rel=stylesheet  href="/blogs/libs/highlight/github.min.css"> <link rel=stylesheet  href="/blogs/css/franklin.css"> <link rel=stylesheet  href="/blogs/css/tufte.css"> <link rel=stylesheet  href="/blogs/css/latex.css"> <link rel=stylesheet  href="/blogs/css/adjust.css"> <link rel=stylesheet  href="/blogs/css/FranklinTheorems.css"> <link rel=icon  href="/blogs/assets/favicon.png"> <title>Simple gradient descent algorithm in Julia</title> <link rel=icon  href="/blogs/assets/favicon.ico"> <script src="/blogs/libs/lunr/lunr.min.js"></script> <script src="/blogs/libs/lunr/lunr_index.js"></script> <script src="/blogs/libs/lunr/lunrclient.min.js"></script> <div id=layout > <div id=menu > <ul> <li><a href="/blogs/">Blogs</a> <li><a href="/blogs/index.html#tags">Tags</a> <li><a href="https://shuvomoy.github.io/site/">Website</a> <li><form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder=" " type=text > <input type=submit  value=Search  formaction="/blogs/search/index.html"> </form> </ul> </div> <div id=main > <!-- Content appended here .result-title a { text-decoration: none; } .result-title a:hover { text-decoration: underline; } .result-preview { color: #808080; } .resultCount { color: #808080; } .result-query { font-weight: bold; } #lunrSearchForm { margin-top: 1em; } --> <div class=franklin-content ><h1 id=implementing_a_simple_gradient_descent_algorithm_in_julia ><a href="#implementing_a_simple_gradient_descent_algorithm_in_julia" class=header-anchor >Implementing a simple gradient descent algorithm in Julia</a></h1> <p><strong>Shuvomoy Das Gupta</strong></p> <p><em>April 10, 2020</em></p> <p>In this blog, we discuss how to implement a simple gradient descent scheme in <code>Julia</code>. To do this, we will use the Julia package <code>ProximalOperators</code>, which is an excellent package to compute proximal operators and gradient of common convex functions. I highly recommend the package for anyone interested in operator splitting algorithms. You can find more information about the package at: <a href="https://github.com/kul-forbes/ProximalOperators.jl">https://github.com/kul-forbes/ProximalOperators.jl</a>.</p> <hr /> <p><strong>Table of contents</strong></p> <div class=franklin-toc ><ol><li><ol><li><a href="#background">Background.</a><li><a href="#load_the_packages">Load the packages</a><li><a href="#create_the_types">Create the types</a><li><a href="#gd_problem"><code>GD_problem</code></a><li><a href="#gd_setting"><code>GD_setting</code></a><li><a href="#gd_state"><code>GD_state</code></a></ol><li><a href="#write_the_functions">Write the functions</a><ol><li><a href="#gd_iteration"><code>GD_iteration&#33;</code></a><li><a href="#gd_solver"><code>GD_solver</code></a></ol></ol></div> <hr /> <p><strong>Jupyter notebook for this blog.</strong> The jupyter notebook for this blog can be downloaded from <a href="https://raw.githubusercontent.com/Shuvomoy/blog/gh-pages/codes/implementing_simple_gradient_descent_Julia.ipynb">this link</a> and viewed <a href="https://github.com/Shuvomoy/blog/blob/gh-pages/codes/implementing_simple_gradient_descent_Julia.ipynb">here</a>. </p> <p>Before we implement gradient descent method, we first record some necessary background.</p> <h3 id=background ><a href="#background" class=header-anchor >Background.</a></h3> <p>Given a differentiable convex function <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>, our goal is to solve <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>minimize</mtext><mtext> </mtext><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">\textrm{minimize}\;f(x)</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class="mord text"><span class="mord textrm">minimize</span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span></span></span>, where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>∈</mo><msup><mi mathvariant=bold >R</mi><mi>n</mi></msup></mrow><annotation encoding="application/x-tex">x\in \mathbf{R}^n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">x</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >∈</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.68611em;vertical-align:0em;"></span><span class=mord ><span class="mord mathbf">R</span><span class=msupsub ><span class=vlist-t ><span class=vlist-r ><span class=vlist  style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span></span></span></span> is the decision variable. To solve the problem above, we consider gradient descent algorithm. The gradient descent implements the following iteration scheme:</p> <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>x</mi><mi>n</mi></msub><mo>−</mo><msub><mi>γ</mi><mi>n</mi></msub><mrow><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=false >)</mo></mrow><mo separator=true >,</mo><mspace width=2em /><mo stretchy=false >(</mo><mn>1</mn><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex"> x_{n+1} = x_{n}-\gamma_{n}{\nabla f(x_{n})},\qquad (1) </annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.638891em;vertical-align:-0.208331em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.208331em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.73333em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >−</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mord ><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span><span class=mpunct >,</span><span class=mspace  style="margin-right:2em;"></span><span class=mspace  style="margin-right:0.16666666666666666em;"></span><span class=mopen >(</span><span class=mord >1</span><span class=mclose >)</span></span></span></span> <p>where <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">{\nabla f(x_{n})}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class=mord >∇</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span></span> denotes a gradient of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> evaluated at the iterate <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_{n}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> is our iteration counter. As our step size rule, we pick a sequence that is square-summable but not summable, e.g., <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>n</mi></msub><mo>=</mo><mn>1</mn><mi mathvariant=normal >/</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">\gamma_{n}=1/n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >=</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >1/</span><span class="mord mathnormal">n</span></span></span></span>, will do the job. </p> <p>We will go through the following steps:</p> <ol> <li><p>Load the packages</p> <li><p>Create the types</p> <li><p>Write the functions</p> </ol> <h3 id=load_the_packages ><a href="#load_the_packages" class=header-anchor >Load the packages</a></h3> <p>Let us load the necessary packages that we are going to use.</p> <pre><code class="julia hljs"><span class=hljs-comment >## Load the packages to be used</span>
<span class=hljs-comment ># -----------------------------</span>
<span class=hljs-comment ># comment the first two lines if you already have ProximalOperators</span>
<span class=hljs-keyword >using</span> Pkg
Pkg.add(<span class=hljs-string >&quot;ProximalOperators&quot;</span>)
<span class=hljs-keyword >using</span> ProximalOperators, LinearAlgebra</code></pre> <h3 id=create_the_types ><a href="#create_the_types" class=header-anchor >Create the types</a></h3> <p>Next, we define a few Julia types, that we require to write an optimization solver in <code>Julia</code>. </p> <h3 id=gd_problem ><a href="#gd_problem" class=header-anchor ><code>GD_problem</code></a></h3> <p>This type contains information about the problem instance, this bascially tells us what function <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> we are trying to optimize over, one initial point <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">x_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and what should be the beginning step size <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\gamma_0</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>.</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> GD_problem{F &lt;: ProximableFunction,A &lt;: <span class=hljs-built_in >AbstractVecOrMat</span>{&lt;:<span class=hljs-built_in >Real</span>}, R &lt;: <span class=hljs-built_in >Real</span>}
    
    <span class=hljs-comment ># problem structure, contains information regarding the problem</span>
    
    f::F <span class=hljs-comment ># the objective function</span>
    x0::A <span class=hljs-comment ># the intial condition</span>
    γ::R <span class=hljs-comment ># the stepsize</span>
    
<span class=hljs-keyword >end</span></code></pre> <p><strong>Usage of <code>GD_problem</code>.</strong> For example, the user may wish to solve a simple least-squares problem using gradient descent. Then he can create a problem instance. A list of functions that we can use in this regard can be found in the documentation of <code>ProximalOperators</code>: <a href="https://kul-forbes.github.io/ProximalOperators.jl/latest">https://kul-forbes.github.io/ProximalOperators.jl/latest</a>.</p> <pre><code class="julia hljs"><span class=hljs-comment ># create a problem instance</span>
<span class=hljs-comment ># ------------------------</span>

A = randn(<span class=hljs-number >6</span>,<span class=hljs-number >5</span>)

b = randn(<span class=hljs-number >6</span>)

m, n = size(A)

<span class=hljs-comment ># randomized intial point:</span>

x0 = randn(n)

f = LeastSquares(A, b)

γ = <span class=hljs-number >1.0</span>

<span class=hljs-comment ># create GD_problem</span>

problem = GD_problem(f, x0, γ)</code></pre> <pre><code class="julia hljs">GD_problem(description : Least squares penalty
    domain      : n/a
    expression  : n/a
    parameters  : n/a, [<span class=hljs-number >1.0193204973421695</span>, <span class=hljs-number >1.168794122203917</span>, <span class=hljs-number >1.296856638205154</span>, <span class=hljs-number >0.5001687528217552</span>, <span class=hljs-number >0.1500452441023732</span>], <span class=hljs-number >1.0</span>)</code></pre> <h3 id=gd_setting ><a href="#gd_setting" class=header-anchor ><code>GD_setting</code></a></h3> <p>This type contains different parameters required to implement our algorithm, such as, </p> <ul> <li><p>the initial step size <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi></mrow><annotation encoding="application/x-tex">\gamma</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span></span></span></span>, </p> <li><p>maximum number of iterations <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>maxit</mtext></mrow><annotation encoding="application/x-tex">\textrm{maxit}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66786em;vertical-align:0em;"></span><span class="mord text"><span class="mord textrm">maxit</span></span></span></span></span>, </p> <li><p>what should be the tolerance <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>tol</mtext></mrow><annotation encoding="application/x-tex">\textrm{tol}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textrm">tol</span></span></span></span></span> &#40;i.e., if <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >∥</mi><mi mathvariant=normal >∇</mi><mrow><mi>f</mi><mo stretchy=false >(</mo><mi>x</mi><mo stretchy=false >)</mo></mrow><mi mathvariant=normal >∥</mi><mo>≤</mo><mtext>tol</mtext></mrow><annotation encoding="application/x-tex">\| \nabla{f(x)} \| \leq \textrm{tol}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord >∥∇</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class=mopen >(</span><span class="mord mathnormal">x</span><span class=mclose >)</span></span><span class=mord >∥</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span><span class=mrel >≤</span><span class=mspace  style="margin-right:0.2777777777777778em;"></span></span><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textrm">tol</span></span></span></span></span>, we take that <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> to be an optimal solution and terminate our algorithm&#41;, </p> <li><p>whether to print out information about the iterates or not controlled by a boolean variable <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>verbose</mtext></mrow><annotation encoding="application/x-tex">\textrm{verbose}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.69444em;vertical-align:0em;"></span><span class="mord text"><span class="mord textrm">verbose</span></span></span></span></span>, and </p> <li><p>how frequently to print out such information controlled by the variable <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext>freq</mtext></mrow><annotation encoding="application/x-tex">\textrm{freq}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord text"><span class="mord textrm">freq</span></span></span></span></span>.</p> </ul> <p>The user may specify what values for these parameters above should be used. But if he does not specify anything, we should be able to have a default set of values to be used. We can achieve this by creating a simple constructor function for <code>GD_setting</code>.</p> <pre><code class="julia hljs"><span class=hljs-keyword >struct</span> GD_setting
    
    <span class=hljs-comment ># user settings to solve the problem using Gradient Descent</span>
    
    γ::<span class=hljs-built_in >Float64</span> <span class=hljs-comment ># the step size</span>
    maxit::<span class=hljs-built_in >Int64</span> <span class=hljs-comment ># maximum number of iteration</span>
    tol::<span class=hljs-built_in >Float64</span> <span class=hljs-comment ># tolerance, i.e., if ||∇f(x)|| ≤ tol, we take x to be an optimal solution</span>
    verbose::Boolean <span class=hljs-comment ># whether to print information about the iterates</span>
    freq::<span class=hljs-built_in >Int64</span> <span class=hljs-comment ># how often print information about the iterates</span>

    <span class=hljs-comment ># constructor for the structure, so if user does not specify any particular values, </span>
    <span class=hljs-comment ># then we create a GD_setting object with default values</span>
    <span class=hljs-keyword >function</span> GD_setting(; γ = <span class=hljs-number >1</span>, maxit = <span class=hljs-number >1000</span>, tol = <span class=hljs-number >1e-8</span>, verbose = <span class=hljs-literal >false</span>, freq = <span class=hljs-number >10</span>)
        new(γ, maxit, tol, verbose, freq)
    <span class=hljs-keyword >end</span>
    
<span class=hljs-keyword >end</span></code></pre> <p><strong>Usage of <code>GD_setting</code>.</strong> For the previously described least squares problem, we create the following setting instance.</p> <pre><code class="julia hljs">setting = GD_setting(verbose = <span class=hljs-literal >true</span>, tol = <span class=hljs-number >1e-2</span>, maxit = <span class=hljs-number >1000</span>, freq = <span class=hljs-number >100</span>)</code></pre>
<pre><code class="julia hljs">GD_setting(<span class=hljs-number >1</span>, <span class=hljs-number >1000</span>, <span class=hljs-number >0.01</span>, <span class=hljs-literal >true</span>, <span class=hljs-number >100</span>)</code></pre>
<h3 id=gd_state ><a href="#gd_state" class=header-anchor ><code>GD_state</code></a></h3>
<p>Now we define the type named <code>GD_state</code> that describes the state our algorithm at iteration number <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>. The state is controlled by </p>
<ul>
<li><p>current iterte <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">x_n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.58056em;vertical-align:-0.15em;"></span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,</p>

<li><p>the gradient of <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> at the current iterate: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant=normal >∇</mi><mi>f</mi><mo stretchy=false >(</mo><msub><mi>x</mi><mi>n</mi></msub><mo stretchy=false >)</mo></mrow><annotation encoding="application/x-tex">{\nabla{f}(x_n)}</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:1em;vertical-align:-0.25em;"></span><span class=mord ><span class=mord >∇</span><span class=mord ><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span><span class=mopen >(</span><span class=mord ><span class="mord mathnormal">x</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span><span class=mclose >)</span></span></span></span></span>,</p>

<li><p>the stepsize at iteration <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>γ</mi><mi>n</mi></msub></mrow><annotation encoding="application/x-tex">\gamma_n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.625em;vertical-align:-0.19444em;"></span><span class=mord ><span class="mord mathnormal" style="margin-right:0.05556em;">γ</span><span class=msupsub ><span class="vlist-t vlist-t2"><span class=vlist-r ><span class=vlist  style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.05556em;margin-right:0.05em;"><span class=pstrut  style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class=vlist-s >​</span></span><span class=vlist-r ><span class=vlist  style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>, and</p>

<li><p>iteration number: <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>.</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-keyword >mutable struct</span> GD_state{T &lt;: <span class=hljs-built_in >AbstractVecOrMat</span>{&lt;: <span class=hljs-built_in >Real</span>}, I &lt;: <span class=hljs-built_in >Integer</span>, R &lt;: <span class=hljs-built_in >Real</span>} <span class=hljs-comment ># contains information regarding one iterattion sequence</span>
    
    x::T <span class=hljs-comment ># iterate x_n</span>
    ∇f_x::T <span class=hljs-comment ># one gradient ∇f(x_n)</span>
    γ::R <span class=hljs-comment ># stepsize</span>
    n::I <span class=hljs-comment ># iteration counter</span>
    
<span class=hljs-keyword >end</span></code></pre>
<p>Also, once the user has given the problem information by creating a problem instance <code>GD_problem</code>, we need a method to construct the initial value of the type <code>GD_state</code>,  as we did earlier for the least-squares problem. We create the initial state from the problem instance by writing a constructor function.</p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> GD_state(problem::GD_problem)
    
    <span class=hljs-comment ># a constructor for the struct GD_state, it will take the problem data and create one state containing all </span>
    <span class=hljs-comment ># the iterate information, current state of the gradient etc so that we can start our gradient descent scheme</span>
    
    <span class=hljs-comment ># unpack information from iter which is GD_iterable type</span>
    x0 = copy(problem.x0) <span class=hljs-comment ># to be safe</span>
    f = problem.f
    γ = problem.γ
    ∇f_x, f_x = gradient(f, x0)
    n = <span class=hljs-number >1</span>
    
    <span class=hljs-keyword >return</span> GD_state(x0, ∇f_x, γ, n)
    
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="julia hljs">GD_state</code></pre>
<h2 id=write_the_functions ><a href="#write_the_functions" class=header-anchor >Write the functions</a></h2>
<p>Now that we are done defining the types, we can now focus on writing the functions that will implement our gradient descent scheme. </p>
<h3 id=gd_iteration ><a href="#gd_iteration" class=header-anchor ><code>GD_iteration&#33;</code></a></h3>
<p>First, we need a function that will take the problem information and the state of our algorithm at iteration number <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span>, and then compute the next state for iteration number <span class=katex ><span class=katex-mathml ><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">n+1</annotation></semantics></math></span><span class=katex-html  aria-hidden=true ><span class=base ><span class=strut  style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal">n</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span><span class=mbin >+</span><span class=mspace  style="margin-right:0.2222222222222222em;"></span></span><span class=base ><span class=strut  style="height:0.64444em;vertical-align:0em;"></span><span class=mord >1</span></span></span></span> according to &#40;1&#41;. </p>
<pre><code class="julia hljs"><span class=hljs-keyword >function</span> GD_iteration!(problem::GD_problem, state::GD_state)
    
    <span class=hljs-comment ># this is the main iteration function, that takes the problem information, and the previous state, </span>
    <span class=hljs-comment ># and create the new state using Gradient Descent algorithm</span>
    
    <span class=hljs-comment ># unpack the current state information</span>
    x_n = state.x
    ∇f_x_n = state.∇f_x
    γ_n = state.γ
    n = state.n
    
    <span class=hljs-comment ># compute the next state</span>
    x_n_plus_1 = x_n - γ_n*∇f_x_n
    
    <span class=hljs-comment ># now load the computed values in the state</span>
    state.x = x_n_plus_1
    state.∇f_x, f_x = gradient(problem.f, x_n_plus_1) <span class=hljs-comment ># note that f_x is not used anywhere</span>
	<span class=hljs-comment ># gradient(f,x) is a function in the ProximalOperators package, see its documentation </span>
	<span class=hljs-comment ># if more information is required</span>
    state.γ = <span class=hljs-number >1</span>/(n+<span class=hljs-number >1</span>)
    state.n = n+<span class=hljs-number >1</span>
    
    <span class=hljs-comment ># done computing return the new state</span>
    <span class=hljs-keyword >return</span> state
    
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="julia hljs">GD_iteration! (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)</code></pre>
<h3 id=gd_solver ><a href="#gd_solver" class=header-anchor ><code>GD_solver</code></a></h3>
<p>Now we are in a position to write the main solver function named <code>GD_solver</code> that will be used by the end user. Internally, this function will take the problem information and the problem setting, and then it will</p>
<ul>
<li><p>create the initial state,</p>

<li><p>keep updating the state using <code>GD_iteration&#33;</code> function until we reach the termination criterion or the maximum number of iterations,</p>

<li><p>print state of the algorithm if <code>verbose</code> is <code>true</code> at the specified frequency, and </p>

<li><p>return the final state.</p>

</ul>
<pre><code class="julia hljs"><span class=hljs-comment >## The solver function</span>

<span class=hljs-keyword >function</span> GD_solver(problem::GD_problem, setting::GD_setting)
    
    <span class=hljs-comment ># this is the function that the end user will use to solve a particular problem, internally it is using the previously defined types and functions to run Gradient Descent Scheme</span>
    <span class=hljs-comment ># create the intial state</span>
    state = GD_state(problem::GD_problem)
    
    <span class=hljs-comment >## time to run the loop</span>
    <span class=hljs-keyword >while</span>  (state.n &lt; setting.maxit) &amp; (norm(state.∇f_x, <span class=hljs-literal >Inf</span>) &gt; setting.tol)
        <span class=hljs-comment ># compute a new state</span>
        state =  GD_iteration!(problem, state)
        <span class=hljs-comment ># print information if verbose = true</span>
        <span class=hljs-keyword >if</span> setting.verbose == <span class=hljs-literal >true</span>
            <span class=hljs-keyword >if</span> mod(state.n, setting.freq) == <span class=hljs-number >0</span>
                <span class=hljs-meta >@info</span> <span class=hljs-string >&quot;iteration = <span class=hljs-subst >$(state.n)</span> | obj val = <span class=hljs-subst >$(problem.f(state.x)</span>) | gradient norm = <span class=hljs-subst >$(norm(state.∇f_x, <span class=hljs-literal >Inf</span>)</span>)&quot;</span>
            <span class=hljs-keyword >end</span>
        <span class=hljs-keyword >end</span>
    <span class=hljs-keyword >end</span>
    
    <span class=hljs-comment ># print information regarding the final state</span>
    
    <span class=hljs-meta >@info</span> <span class=hljs-string >&quot;final iteration = <span class=hljs-subst >$(state.n)</span> | final obj val = <span class=hljs-subst >$(problem.f(state.x)</span>) | final gradient norm = <span class=hljs-subst >$(norm(state.∇f_x, <span class=hljs-literal >Inf</span>)</span>)&quot;</span>
    <span class=hljs-keyword >return</span> state
    
<span class=hljs-keyword >end</span></code></pre>
<pre><code class="julia hljs">GD_solver (generic <span class=hljs-keyword >function</span> with <span class=hljs-number >1</span> method)</code></pre>
<p>​    </p>
<p><strong>Usage of <code>GD_solver</code>.</strong> For the previously created <code>problem</code> and <code>setting</code>, we run our <code>GD_solver</code> function as follows.</p>
<pre><code class="julia hljs"><span class=hljs-comment ># The following function will run the entire loop over the struct GradientDescent</span></code></pre>
<pre><code class="julia hljs">final_state_GD = GD_solver(problem, setting)</code></pre>
<pre><code class="julia hljs">┌ Info: iteration = <span class=hljs-number >100</span> |  
    │                 obj val = <span class=hljs-number >0.10616975436389622</span> | 
    │                 gradient norm = <span class=hljs-number >0.02964822736954073</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >16</span>
    ┌ Info: iteration = <span class=hljs-number >200</span> |  
    │                 obj val = <span class=hljs-number >0.10526904472309405</span> | 
    │                 gradient norm = <span class=hljs-number >0.019909231214547213</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >16</span>
    ┌ Info: iteration = <span class=hljs-number >300</span> |  
    │                 obj val = <span class=hljs-number >0.10499388213419013</span> | 
    │                 gradient norm = <span class=hljs-number >0.01578344670011611</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >16</span>
    ┌ Info: iteration = <span class=hljs-number >400</span> |  
    │                 obj val = <span class=hljs-number >0.1048632843417343</span> | 
    │                 gradient norm = <span class=hljs-number >0.013388371065530952</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >16</span>
    ┌ Info: iteration = <span class=hljs-number >500</span> |  
    │                 obj val = <span class=hljs-number >0.10478781849295837</span> | 
    │                 gradient norm = <span class=hljs-number >0.011784780173541287</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >16</span>
    ┌ Info: iteration = <span class=hljs-number >600</span> |  
    │                 obj val = <span class=hljs-number >0.10473897267694926</span> | 
    │                 gradient norm = <span class=hljs-number >0.010618620536011203</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >16</span>
    ┌ Info: final iteration = <span class=hljs-number >667</span> | 
    │     final obj val = <span class=hljs-number >0.10471495099365061</span> | 
    │     final gradient norm = <span class=hljs-number >0.009995364642054971</span>
    └ @ Main In[<span class=hljs-number >9</span>]:<span class=hljs-number >25</span>





    GD_state([-<span class=hljs-number >0.747429923239562</span>, <span class=hljs-number >0.7857409304268766</span>, -<span class=hljs-number >1.9752613372498569</span>, -<span class=hljs-number >0.8109189160513681</span>, <span class=hljs-number >0.6537705422543739</span>], [-<span class=hljs-number >0.002114026011632561</span>, -<span class=hljs-number >0.008995100759876307</span>, <span class=hljs-number >0.009995364642054971</span>, <span class=hljs-number >0.0024806200462658134</span>, -<span class=hljs-number >0.004665182937515999</span>], <span class=hljs-number >0.0014992503748125937</span>, <span class=hljs-number >667</span>)</code></pre>
<pre><code class="julia hljs">println(<span class=hljs-string >&quot;objective value found by our gradient descent <span class=hljs-subst >$(f(final_state_GD.x)</span>)&quot;</span>)

println(<span class=hljs-string >&quot;real objective value <span class=hljs-subst >$(f(pinv(A)</span>*b)) &quot;</span>)</code></pre>
<pre><code class="julia hljs">objective value found by our gradient descent <span class=hljs-number >0.10471495099365061</span>
    real objective value <span class=hljs-number >0.10452813292628083</span></code></pre>
<p>So, we do decent in terms of finding a good solution&#33;</p>
<div class=page-foot >
  <div class=copyright >
    &copy; Shuvomoy Das Gupta. Last modified: March 25, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
        </div> 
    </div>