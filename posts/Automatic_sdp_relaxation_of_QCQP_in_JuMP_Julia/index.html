<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/blogs/libs/katex/katex.min.css"> <link rel=stylesheet  href="/blogs/libs/highlight/github.min.css"> <link rel=stylesheet  href="/blogs/css/franklin.css"> <link rel=stylesheet  href="/blogs/css/tufte.css"> <link rel=stylesheet  href="/blogs/css/latex.css"> <link rel=stylesheet  href="/blogs/css/adjust.css"> <link rel=stylesheet  href="/blogs/css/FranklinTheorems.css"> <link rel=icon  href="/blogs/assets/favicon.png"> <title>Automated SDP relaxation of QCQPs in JuMP+Julia</title> <link rel=icon  href="/blogs/assets/favicon.ico"> <script src="/blogs/libs/lunr/lunr.min.js"></script> <script src="/blogs/libs/lunr/lunr_index.js"></script> <script src="/blogs/libs/lunr/lunrclient.min.js"></script> <div id=layout > <div id=menu > <ul> <li><a href="/blogs/">Blogs</a> <li><a href="/blogs/index.html#tags">Tags</a> <li><a href="https://shuvomoy.github.io/">Website</a> <li><form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder=" " type=text > <input type=submit  value=Search  formaction="/blogs/search/index.html"> </form> </ul> </div> <div id=main > <!-- Content appended here .result-title a { text-decoration: none; } .result-title a:hover { text-decoration: underline; } .result-preview { color: #808080; } .resultCount { color: #808080; } .result-query { font-weight: bold; } #lunrSearchForm { margin-top: 1em; } --> <div class=franklin-content ><h1 id=automated_sdp_relaxation_of_qcqps_in_jumpjulia ><a href="#automated_sdp_relaxation_of_qcqps_in_jumpjulia" class=header-anchor >Automated SDP relaxation of QCQPs in JuMP&#43;Julia</a></h1> <p><strong>Shuvomoy Das Gupta</strong></p> <p><em>August 27, 2022</em></p> <p>In this blog, we discuss how to construct automatic SDP relaxation of a nonconvex QCQP in <code>Julia&#43;JuMP</code> &#40;based on tips from <a href="https://blegat.github.io/">Beno√Æt Legat</a>&#41;.</p> <h2 id=example_qcqp ><a href="#example_qcqp" class=header-anchor >Example QCQP</a></h2> <p>Consider the following QCQP as an example:</p> \[ p^{\star}=\left(\begin{array}{ll} \underset{x,y\in\mathbf{R}^{2},\;P, Z\in\mathbf{S}^{2}}{\mbox{minimize}} & c_{1}^{\top}x+c_{2}^{\top}y+c_{3}\mathbf{tr}(Z)\\ \mbox{subject to} & a_{1}xy^{\top}+A_{1}\left(\begin{bmatrix}x\\ y \end{bmatrix}\right)=Z,\\ & xy^{\top}+A_{2}\left(\begin{bmatrix}x\\ y \end{bmatrix}\right)\leq0,\\ & Z=PP^{\top}.\\ \end{array}\right) \quad(1) \] <p>We have the bound information that the optimal value lies between \([-400,-200]\)Here \(A_1, A_2\) are linear operators from \(\mathbf{R}^4\) to \(\mathbf{S}^2\). First, let us solve the problem to global optimality using <code>Gurobi&#43;JuMP</code>.</p> <pre><code class=language-julia ># Load the packages
using JuMP, Gurobi, MosekTools, Mosek, LinearAlgebra, DiffOpt</code></pre> <pre><code class=language-julia ># Problem data:
c_1 &#61; &#91;-3; -5&#93;
c_2 &#61; &#91;2; -5&#93;
c_3 &#61; -1
a_1 &#61; 4
A_1_op&#40;x,y&#41; &#61; &#91;3*x&#91;1&#93;&#43;2*y&#91;2&#93; -x&#91;2&#93;&#43;y&#91;1&#93;; -x&#91;2&#93;&#43;y&#91;1&#93; -4*x&#91;2&#93;&#43;y&#91;2&#93;&#93;
A_2_op&#40;x,y&#41; &#61; &#91;2*x&#91;1&#93;-5*y&#91;2&#93; -3*x&#91;2&#93;&#43;2*y&#91;1&#93;; -3*x&#91;2&#93;&#43;2*y&#91;1&#93; 4*x&#91;2&#93;-7*y&#91;2&#93;&#93;
x_lb &#61; 0
x_ub &#61; 5
y_lb &#61; 0
y_ub &#61; 10</code></pre> <h2 id=solving_the_qcqp_to_global_optimality ><a href="#solving_the_qcqp_to_global_optimality" class=header-anchor >Solving the QCQP to global optimality</a></h2> <pre><code class=language-julia >function QCQP_solver&#40;c_1, c_2, c_3, a_1, x_lb, x_ub, y_lb, y_ub&#41;

    nonlinear_model &#61; Model&#40;Gurobi.Optimizer&#41;

    set_optimizer_attribute&#40;nonlinear_model, &quot;NonConvex&quot;, 2&#41;

    @variable&#40;nonlinear_model, x_lb &lt;&#61; x&#91;1:2&#93; &lt;&#61; x_ub&#41;

    @variable&#40;nonlinear_model, y_lb &lt;&#61; y&#91;1:2&#93; &lt;&#61; y_ub&#41;

    @variable&#40;nonlinear_model, Z&#91;1:2, 1:2&#93;, Symmetric&#41;

    @variable&#40;nonlinear_model, P&#91;1:2, 1:2&#93;&#41;

    @objective&#40; nonlinear_model, Min, c_1&#39;*x &#43; c_2&#39;*y &#43; c_3*tr&#40;Z&#41; &#41;

    con_shape &#61; SymmetricMatrixShape&#40;2&#41;

    QuadCon1 &#61; @constraint&#40;nonlinear_model, vectorize&#40;a_1*x*transpose&#40;y&#41; &#43; A_1_op&#40;x,y&#41; - Z, con_shape&#41; .&#61;&#61; 0 &#41;

    QuadCon2 &#61; @constraint&#40;nonlinear_model, vectorize&#40;x*transpose&#40;y&#41; &#43; A_2_op&#40;x,y&#41;, con_shape&#41; .&lt;&#61; 0 &#41;

    SDPCon3 &#61; @constraint&#40;nonlinear_model, vectorize&#40;Z - P*P&#39;, con_shape&#41; .&#61;&#61; 0 &#41;

    @constraint&#40;nonlinear_model, c_1&#39;*x &#43; c_2&#39;*y &#43; c_3*tr&#40;Z&#41; &gt;&#61; -400 &#41;

    @constraint&#40;nonlinear_model, c_1&#39;*x &#43; c_2&#39;*y &#43; c_3*tr&#40;Z&#41; &lt;&#61; -200 &#41;

    optimize&#33;&#40;nonlinear_model&#41;

    p_star &#61; objective_value&#40;nonlinear_model&#41;

    x_star &#61; value.&#40;x&#41;

    y_star &#61; value.&#40;y&#41;

    Z_star &#61; value.&#40;Z&#41;

    @show x_star

    @show y_star

    @show Z_star

    @show p_star

    return x_star, y_star, Z_star, p_star

end</code></pre> <p>Let us run the function.</p> <pre><code class=language-julia >x_star, y_star, Z_star, p_star &#61; QCQP_solver&#40;c_1, c_2, c_3, a_1, x_lb, x_ub, y_lb, y_ub&#41;</code></pre>
<h2 id=extracting_the_data_to_construct_sdp_relaxation ><a href="#extracting_the_data_to_construct_sdp_relaxation" class=header-anchor >Extracting the data to construct SDP relaxation</a></h2>
<p>We have three quadratic constraint arrays in &#40;1&#41;. The third one is just \(Z\succeq0\), so we can just model that. For the first and second, we want to convert them into standard form quadratic constraints.</p>
<p>Defining \(w=\textrm{vec}(x,y)\) we want to write the first quadratic constraint</p>
\[
a_{1}xy^{\top}+A_{1}\left(\begin{bmatrix}x\\
y
\end{bmatrix}\right)=Z
\]
<p>as</p>
\[
w^{\top}P_{1}^{(k,\ell)}w+q_{1}^{(k,\ell)\top}w+r_{1}^{(k,\ell)}=Z_{k,\ell}\quad k\in[1:2],\;\ell\in[1:k],
\]
<p>and we want to write the second quadratic constraint</p>
\[
xy^{\top}+A_{2}\left(\begin{bmatrix}x\
y
\end{bmatrix}\right)\leq0
\]
<p>as</p>
\[
w^{\top}P_{2}^{(k,\ell)}w+q_{2}^{(k,\ell)\top}w+r_{2}^{(k,\ell)} \leq 0, \quad k\in[1:2],\;\ell\in[1:k],
\]
<p>where \(P_{i}^{(k,\ell)},q_{i}^{(k,\ell)},r_{i}^{(k,\ell)}\) are problemdata that we are going to extract from the original problem.</p>
<p>Let us create a <code>struct</code> that will help in providing the quadratic form data \(P,q,r\).</p>
<pre><code class=language-julia >using DiffOpt

struct Form
    P
    q
    r
end

using LinearAlgebra

LinearAlgebra.symmetric_type&#40;::Type&#123;Form&#125;&#41; &#61; Form
LinearAlgebra.symmetric&#40;f::Form, ::Symbol&#41; &#61; f
LinearAlgebra.transpose&#40;f::Form&#41; &#61; f</code></pre>
<p>The following function creates the data to construct the SDP relaxation.</p>
<pre><code class=language-julia >function standard_form_data_constructor&#40;c_1, c_2, c_3, a_1, x_lb, x_ub, y_lb, y_ub&#41;

    data_model &#61; Model&#40;&#41;

    @variable&#40;data_model, x_lb &lt;&#61; x&#91;1:2&#93; &lt;&#61; x_ub&#41;

    @variable&#40;data_model, y_lb &lt;&#61; y&#91;1:2&#93; &lt;&#61; y_ub&#41;

    @variable&#40;data_model, Z&#91;1:2, 1:2&#93;, Symmetric&#41;

    w &#61; Vector&#123;VariableRef&#125;&#91;&#93;

    push&#33;&#40;w, x&#41;

    push&#33;&#40;w, y&#41;

    # create the vectorized w

    w_vec &#61; reduce&#40;vcat, w&#41;

    # Add the qcqp constraints that we want to take to standard form

    con_shape &#61; SymmetricMatrixShape&#40;2&#41;

    QuadCon1 &#61; @constraint&#40;data_model, vectorize&#40;a_1*x*transpose&#40;y&#41; &#43; A_1_op&#40;x,y&#41; - Z, con_shape&#41; .&#61;&#61; 0 &#41;

    QuadCon2 &#61; @constraint&#40;data_model, vectorize&#40;x*transpose&#40;y&#41; &#43; A_2_op&#40;x,y&#41;, con_shape&#41; .&lt;&#61; 0 &#41;

    # create index map that will contain the indices of the original decision variables

    index_map &#61; MOI.Utilities.IndexMap&#40;&#41;

    for &#40;i, var_ref&#41; in enumerate&#40;w_vec&#41;
        index_map&#91;JuMP.index&#40;var_ref&#41;&#93; &#61; MOI.VariableIndex&#40;i&#41;
    end

    n &#61; length&#40;index_map.var_map&#41;

    remove &#61; JuMP.index.&#40;JuMP.vectorize&#40;Z, con_shape&#41;&#41; # we have to ensure that we are not considering Z in w

    # The function &#96;standard_form&#40;con_ref::JuMP.ConstraintRef&#41;&#96; will take a &#96;JuMP&#96; quadratic function and convert it into a standard form quadratic constraint of the form &#36;w^\top P w &#43; q^\top w &#43; r&#36; form.
    function standard_form_data&#40;con_ref::JuMP.ConstraintRef&#41;
        object &#61; JuMP.constraint_object&#40;con_ref&#41;
        quad_func &#61; JuMP.moi_function&#40;object&#41;
        quad_func &#61; MOI.Utilities.substitute_variables&#40;quad_func&#41; do var
            F &#61; MOI.ScalarAffineFunction&#123;Float64&#125;
            if var in remove
                return zero&#40;F&#41;
            else
                return convert&#40;F, var&#41;
            end
        end
        matrix &#61; DiffOpt.sparse_array_representation&#40;quad_func, n, index_map&#41;
        r &#61; matrix.constant - MOI.constant&#40;JuMP.moi_set&#40;object&#41;&#41;
        P, q &#61; Matrix&#40;0.5*matrix.quadratic_terms&#41;, Vector&#40;matrix.affine_terms&#41;
        # P, q &#61; 0.5*matrix.quadratic_terms, matrix.affine_terms
        return Form&#40;P, q, r&#41;
    end

    QuadCon1StdTerms &#61; JuMP.reshape_vector&#40;standard_form_data.&#40;QuadCon1&#41;, con_shape&#41;
    # For example,
    # QuadCon1StdTerms&#91;1,1&#93;.P will give us corresponding P
    # QuadCon1StdTerms&#91;1,1&#93;.q will give us corresponding q
    # QuadCon1StdTerms&#91;1,1&#93;.r will give us corresponding r

    # QuadCon2StdTerms &#61; map&#40;QuadCon2&#41; do con_refs
    #     JuMP.reshape_vector&#40;standard_form_data.&#40;QuadCon2&#41;, con_shape&#41;
    # end

    QuadCon2StdTerms &#61; JuMP.reshape_vector&#40;standard_form_data.&#40;QuadCon2&#41;, con_shape&#41;

    return QuadCon1StdTerms, QuadCon2StdTerms

end</code></pre>
<p>Test the function.</p>
<pre><code class=language-julia >QuadCon1StdTerms, QuadCon2StdTerms &#61; standard_form_data_constructor&#40;c_1, c_2, c_3, a_1, x_lb, x_ub, y_lb, y_ub&#41;

# For example,
# QuadCon1StdTerms&#91;1,1&#93;.P will give us corresponding P
# QuadCon1StdTerms&#91;1,1&#93;.q will give us corresponding q
# QuadCon1StdTerms&#91;1,1&#93;.r will give us corresponding r</code></pre>
<h2 id=sdp_relaxation_model ><a href="#sdp_relaxation_model" class=header-anchor >SDP relaxation model</a></h2>
<p>So, we have the following SDP relaxation of &#40;2&#41;:</p>
\[
p_{\textrm{SDP}}^{\star}=\left(\begin{array}{ll}
\underset{x,y\in\mathbf{R}^{2},\; Z\in\mathbf{S}^{2},\; W\in\mathbf{S}^{4}}{\mbox{minimize}} & c_{1}^{\top}x+c_{2}^{\top}y+c_{3}\mathbf{tr}(Z)\\
\mbox{subject to} & \mathbf{tr}(P_{1}^{(k,\ell)}W)+q_{1}^{(k,\ell)\top}w+r_{1}^{(k,\ell)}=Z_{k,\ell}, \quad k\in[1:2],\;\ell\in[1:k],\\
 & \mathbf{tr}(P_{2}^{(k,\ell)}W)+q_{2}^{(k,\ell)\top}w+r_{2}^{(k,\ell)} \leq 0, \quad k\in[1:2],\;\ell\in[1:k],\\
 & Z\succeq0,\\
 & \begin{bmatrix}W & w\\
w^{\top} & 1
\end{bmatrix}\succeq0,\\
 & w=\textrm{vec}(x,y), \\
 & W-l_{w}w^{\top}-wl_{w}^{\top}  \geq  -l_{w}l_{w}^{\top},\\
& W-l_{w}w{}^{\top}-wl_{w}^{\top}  \geq  -u_{w}u_{w}^{\top},\\
& W-l_{w}w^{\top}-wu_{w}^{\top}  \geq  -l_{w}u_{w}^{\top},\\
& l_{w}\leq w\leq u_{w}.
\end{array}\right)
\]
<p>The last four constraints are called RLT cuts that are valid inequalities for \(W=w w^\top\). For more details about the RLT cut and how the SDP relaxation is constructed in general, see</p>
<blockquote>
<p>Anstreicher, Kurt M. &quot;Semidefinite programming versus the reformulation-linearization technique for nonconvex quadratically constrained quadratic programming.&quot; <em>Journal of Global Optimization</em> 43.2 &#40;2009&#41;: 471-484.</p>
<p>Link: <a href="http://www.optimization-online.org/DB_FILE/2007/05/1655.pdf">http://www.optimization-online.org/DB_FILE/2007/05/1655.pdf</a></p>
</blockquote>
<p>Let us solve the SDP model step by step.</p>
<pre><code class=language-julia >using Mosek, MosekTools

function SDP_relaxation_solver&#40;c_1, c_2, c_3, a_1, x_lb, x_ub, y_lb, y_ub, QuadCon1StdTerms, QuadCon2StdTerms; big_M &#61; 100, RLT_cut &#61; :on&#41;

    # Define the SDP model

    SDP_model &#61; Model&#40;optimizer_with_attributes&#40;Mosek.Optimizer&#41;&#41;

    @variable&#40;SDP_model, x_lb &lt;&#61; x&#91;1:2&#93; &lt;&#61; x_ub&#41;

    @variable&#40;SDP_model, y_lb &lt;&#61; y&#91;1:2&#93; &lt;&#61; y_ub&#41;

    @variable&#40;SDP_model, Z&#91;1:2, 1:2&#93;, PSD&#41;

    w &#61; Vector&#123;VariableRef&#125;&#91;&#93;

    push&#33;&#40;w, x&#41;

    push&#33;&#40;w, y&#41;

    # create the vectorized w

    w_vec &#61; reduce&#40;vcat, w&#41;

    len_w &#61; length&#40;w_vec&#41;


    @variable&#40;SDP_model, W&#91;1:len_w, 1:len_w&#93;, Symmetric&#41;

    @objective&#40;SDP_model, Min, c_1&#39;*x &#43; c_2&#39;*y &#43; c_3*tr&#40;Z&#41; &#41;

    dim_Z &#61; 2

    # SDP relaxation of qudratic constraint 1
    # ---------------------------------------

    for k in 1:dim_Z
        for ‚Ñì in 1:k
            @constraint&#40;SDP_model, tr&#40;QuadCon1StdTerms&#91;k,‚Ñì&#93;.P * W&#41; &#43; &#40;QuadCon1StdTerms&#91;k,‚Ñì&#93;.q&#41;&#39;*w_vec &#43; &#40;QuadCon1StdTerms&#91;k,‚Ñì&#93;.r&#41; &#61;&#61; Z&#91;k,‚Ñì&#93; &#41;
        end
    end

    # SDP relaxation of qudratic constraint 2
    # ---------------------------------------

    for k in 1:dim_Z
        for ‚Ñì in 1:k
            @constraint&#40;SDP_model, tr&#40;QuadCon2StdTerms&#91;k,‚Ñì&#93;.P * W&#41; &#43; &#40;QuadCon2StdTerms&#91;k,‚Ñì&#93;.q&#41;&#39;*w_vec &#43; &#40;QuadCon2StdTerms&#91;k,‚Ñì&#93;.r&#41; &lt;&#61; 0 &#41;
        end
    end

    # Schur complement constraint
    # ---------------------------

    @constraint&#40;SDP_model, schurCon, &#91;W w_vec; w_vec&#39; 1&#93; in PSDCone&#40;&#41;&#41;

    @constraint&#40;SDP_model, c_1&#39;*x &#43; c_2&#39;*y &#43; c_3*tr&#40;Z&#41; &gt;&#61; -400 &#41;

    @constraint&#40;SDP_model, c_1&#39;*x &#43; c_2&#39;*y &#43; c_3*tr&#40;Z&#41; &lt;&#61; -200 &#41;

    # Add RLT cuts
    # ------------

    if RLT_cut &#61;&#61; :on

        # construct lower and upper bound vector for w_vec

        l_w &#61; zeros&#40;len_w&#41;
        u_w &#61; zeros&#40;len_w&#41;

        for i in 1:len_w

            if has_upper_bound&#40;w_vec&#91;i&#93;&#41; &#61;&#61; true
                u_w&#91;i&#93; &#61; upper_bound&#40;w_vec&#91;i&#93;&#41;
            else
                u_w&#91;i&#93; &#61; big_M
            end

            if has_lower_bound&#40;w_vec&#91;i&#93;&#41; &#61;&#61; true
                l_w&#91;i&#93; &#61; lower_bound&#40;w_vec&#91;i&#93;&#41;
            else
                l_w&#91;i&#93; &#61; -big_M
            end

        end

        # Add RLT cuts
        # ------------

        con_shape &#61; SymmetricMatrixShape&#40;2&#41;

        @info &quot;&#91;üé† &#93; Adding RLT cuts&quot;

        @constraint&#40;SDP_model, RLT_cut_1, vectorize&#40; W - l_w*w_vec&#39; - w_vec*l_w&#39; &#43; l_w*l_w&#39;, con_shape&#41; .&gt;&#61; 0&#41;

        @constraint&#40;SDP_model, RLT_cut_2, vectorize&#40;W - l_w*w_vec&#39; - w_vec*l_w&#39; &#43; u_w*u_w&#39;, con_shape&#41; .&gt;&#61; 0&#41;

        @constraint&#40;SDP_model, RLT_cut_3, vectorize&#40;W - l_w*w_vec&#39; - w_vec*u_w&#39; &#43; l_w*u_w&#39;, con_shape&#41; .&gt;&#61; 0&#41;

        @constraint&#40;SDP_model, RLT_cut_4, l_w .&lt;&#61; w_vec&#41;

        @constraint&#40;SDP_model, RLT_cut_5, w_vec .&lt;&#61; u_w &#41;

    end

    # Solve the optimization problem

    optimize&#33;&#40;SDP_model&#41;

    objective_value&#40;SDP_model&#41;

    if termination_status&#40;SDP_model&#41; &#33;&#61; MOI.OPTIMAL
        @info &quot;&#91;üíÄ&#93;&quot;
        @error &quot;model_dual_PEP_with_known_stepsizes solving did not reach optimality;  termination status &#61; &quot; termination_status&#40;SDP_model&#41;
    end

    x_star &#61; value.&#40;x&#41;

    y_star &#61; value.&#40;y&#41;

    Z_star &#61; value.&#40;Z&#41;

    W_star &#61; value.&#40;W&#41;

    p_star &#61; objective_value&#40;SDP_model&#41;

    return x_star, y_star, Z_star, W_star, p_star

end</code></pre>
<p>Test the function.</p>
<pre><code class=language-julia >x_star_SDP, y_star_SDP, Z_star_SDP, W_star_SDP, p_star_SDP &#61; SDP_relaxation_solver&#40;c_1, c_2, c_3, a_1, x_lb, x_ub, y_lb, y_ub, QuadCon1StdTerms, QuadCon2StdTerms; big_M &#61; 100, RLT_cut &#61; :on&#41;</code></pre>
<div class=page-foot >
  <div class=copyright >
    &copy; Shuvomoy Das Gupta. Last modified: April 27, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>.
  </div>
</div>
</div>
        </div> 
    </div> 
    
        <script src="/blogs/libs/katex/katex.min.js"></script>
<script src="/blogs/libs/katex/auto-render.min.js"></script>
<script>renderMathInElement(document.body)</script>

    
    
        <script src="/blogs/libs/highlight/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: '    '});</script>