<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/blogs/libs/katex/katex.min.css"> <link rel=stylesheet  href="/blogs/libs/highlight/github.min.css"> <link rel=stylesheet  href="/blogs/css/franklin.css"> <link rel=stylesheet  href="/blogs/css/tufte.css"> <link rel=stylesheet  href="/blogs/css/latex.css"> <link rel=stylesheet  href="/blogs/css/adjust.css"> <link rel=stylesheet  href="/blogs/css/FranklinTheorems.css"> <link rel=icon  href="/blogs/assets/favicon.png"> <title>Accelerated first-order methods as span-based first-order methods: conversion between momentum form and standard form</title> <link rel=icon  href="/blogs/assets/favicon.ico"> <script src="/blogs/libs/lunr/lunr.min.js"></script> <script src="/blogs/libs/lunr/lunr_index.js"></script> <script src="/blogs/libs/lunr/lunrclient.min.js"></script> <div id=layout > <div id=menu > <ul> <li><a href="/blogs/">Blogs</a> <li><a href="/blogs/index.html#tags">Tags</a> <li><a href="https://shuvomoy.github.io/">Website</a> <li><form id=lunrSearchForm  name=lunrSearchForm > <input class=search-input  name=q  placeholder=" " type=text > <input type=submit  value=Search  formaction="/blogs/search/index.html"> </form> </ul> </div> <div id=main > <!-- Content appended here .result-title a { text-decoration: none; } .result-title a:hover { text-decoration: underline; } .result-preview { color: #808080; } .resultCount { color: #808080; } .result-query { font-weight: bold; } #lunrSearchForm { margin-top: 1em; } --> <div class=franklin-content ><h1 id=accelerated_first-order_methods_as_span-based_first-order_methods_conversion_between_momentum_form_and_standard_form ><a href="#accelerated_first-order_methods_as_span-based_first-order_methods_conversion_between_momentum_form_and_standard_form" class=header-anchor >Accelerated first-order methods as span-based first-order methods: conversion between momentum form and standard form</a></h1> <p><strong>Shuvomoy Das Gupta</strong></p> <p><em>July 23, 2023</em></p> <p>In this blog, we discuss how to write accelerated first-order methods as span-based first-order methods.</p> <p><hr /> <strong>Table of contents</strong> <div class=franklin-toc ><ol><li><a href="#converting_between_momentum-form_and_and_standard_form_of_span-based_first-order_method">Converting between momentum-form and and standard form of span-based first-order method</a><ol><li><a href="#julia_code_to_construct_h_from_zeta_eta_and_back">Julia code to construct \(h\) from \(\{\zeta, \eta\}\) and back</a><ol><li><a href="#code_to_construct_h_from_zeta_eta">Code to construct \(h\) from \(\{\zeta, \eta\}\)</a></ol><li><a href="#code_to_construct_zeta_eta_from_h">Code to construct \(\{\zeta, \eta\}\) from \(h\)</a></ol><li><a href="#converting_between_auxiliary-format_form_and_momentum-form">Converting between auxiliary-format form and momentum-form</a><li><a href="#example_1_fista">Example 1. FISTA</a><li><a href="#example_2_ogm">Example 2. OGM</a></ol></div></p> <hr /> <h2 id=converting_between_momentum-form_and_and_standard_form_of_span-based_first-order_method ><a href="#converting_between_momentum-form_and_and_standard_form_of_span-based_first-order_method" class=header-anchor >Converting between momentum-form and and standard form of span-based first-order method</a></h2> <p>Consider a \(L\)-smooth function. ​Span-based first order methods for this function \(f\) are algorithms of the form &#40;called the standard form&#41;</p> \[x_{k}=x_{0}-\sum_{j=0}^{k-1}\frac{h_{k,j}}{L}\nabla f(x_{j}),\quad\textrm{(SBFOM)}\] <p>​​​ where \(k\in\{1,\ldots,N\}\) and \(x_0\) is the initial point​​​.</p> <p>Also, we have the following &quot;momentum form&quot; of the span-based first-order method, where \(i\in \{0,\ldots, N-1\}\).</p> \[ \begin{align*} \begin{array}{ll} y_{i+1} & =x_{i}-\frac{1}{L}\nabla f(x_{i})\\ x_{i+1} & =y_{i+1}+\zeta_{i+1}(y_{i+1}-y_{i})+\eta_{i+1}(y_{i+1}-x_{i}), \end{array}\quad(\textrm{MomentumForm)} \end{align*} \] <p>which we show to be equivalent to &#40;SBFOM&#41;. To show that &#40;MomentumForm&#41; is in the form &#40;SBFOM&#41;, we put, the iterative form \(y_{+1}\)​​ and \(y_{i}\)​​ in terms of the \(x\)​​ iterates in the second iterate. For simplification purpose, denote \(g_{i}=\nabla f(x_{i})\)​​​. We get:</p> \[ \begin{align*} x_{i+1}=x_{i}+\zeta_{i+1}\left(x_{i}-x_{i-1}\right)-\frac{\left(\zeta_{i+1}+\eta_{i+1}+1\right)}{L}g_{i}+\frac{\zeta_{i+1}}{L}g_{i-1},\quad \textrm{(MOM-SIMP)} \end{align*} \] <p>where the Mathematica code for this is shown below. </p> <pre><code class=language-mathematica >Subscript&#91;y, i &#43; 1&#93; &#61; Subscript&#91;x, i&#93; -  Subscript&#91;g, i&#93;/L;
Subscript&#91;y, i&#93; &#61; Subscript&#91;x, i - 1&#93; - Subscript&#91;g, i - 1&#93;/L;
Subscript&#91;x, i &#43; 1&#93; &#61; 
  Subscript&#91;\&#91;Eta&#93;, i &#43; 1&#93; &#40;Subscript&#91;y, i &#43; 1&#93; - Subscript&#91;x, i&#93;&#41; &#43; 
   Subscript&#91;\&#91;Zeta&#93;, i &#43; 1&#93; &#40;Subscript&#91;y, i &#43; 1&#93; - Subscript&#91;y, i&#93;&#41; &#43;
    Subscript&#91;y, i &#43; 1&#93;;
term1 &#61; Collect&#91;Subscript&#91;x, 
 i &#43; 1&#93;, &#123;Subscript&#91;x, i&#93;, Subscript&#91;x, i&#93; - Subscript&#91;x, i - 1&#93;, 
  Subscript&#91;g, i&#93;&#125;, Simplify&#93;
  
&#40;*Output:
    Subscript&#91;x, i&#93; &#43; &#40;
 Subscript&#91;g, -1 &#43; i&#93; Subscript&#91;\&#91;Zeta&#93;, 
  1 &#43; i&#93;&#41;/L &#43; &#40;-Subscript&#91;x, -1 &#43; i&#93; &#43; Subscript&#91;x, 
    i&#93;&#41; Subscript&#91;\&#91;Zeta&#93;, 1 &#43; i&#93; - &#40;
 Subscript&#91;g, 
  i&#93; &#40;1 &#43; Subscript&#91;\&#91;Zeta&#93;, 1 &#43; i&#93; &#43; Subscript&#91;\&#91;Eta&#93;, 1 &#43; i&#93;&#41;&#41;/L
 *&#41;</code></pre> <p><img src="https://raw.githubusercontent.com/Shuvomoy/blogs/master/posts/Accelerated_methods_as_fixed_step_first_order_method.assets/image-20220111154904525.png" alt=image-20220111155941105  /></p> <p>Now from &#40;SBFOM&#41;:</p> \[\begin{align*} x_{i} & =x_{0}-\sum_{j=0}^{i-1}\frac{h_{i,j}}{L}g_{j},\\ x_{i-1} & =x_{0}-\sum_{j=0}^{i-2}\frac{h_{i-1,j}}{L}g_{j},\end{align*}\] <p>​​ which gives </p> \[ \begin{align*} x_{i}-x_{i-1} & =-\sum_{j=0}^{i-2}\frac{(-h_{i-1,j}+h_{i,j})}{L}g_{j}-\frac{h_{i,i-1}}{L}g_{i-1}\quad \textrm{(Diff-x)} \end{align*} \] <p>and putting this in &#40;MOM-SIMP&#41; and then simplifying we get: </p> \[ \begin{align*} & x_{i+1}\\ = & x_{i}-\zeta_{i+1}\sum_{j=0}^{i-2}\frac{\left(h_{i,j}-h_{i-1,j}\right)}{L}g_{j}-\frac{\zeta_{i+1}\left(h_{i,i-1}-1\right)}{L}g_{i-1}-\frac{\left(\zeta_{i+1}+\eta_{i+1}+1\right)}{L}g_{i}, \end{align*} \quad \textrm{(SBFOM-A)} \] <p>where the Mathematica code for the simplification is shown below: </p> <pre><code class=language-mathematica >termDif &#61; -\&#33;\&#40;
\*UnderoverscriptBox&#91;\&#40;\&#91;Sum&#93;\&#41;, \&#40;j &#61; 0\&#41;, \&#40;i - 2\&#41;&#93;
\*FractionBox&#91;\&#40;
\*SubscriptBox&#91;\&#40;g\&#41;, \&#40;j\&#41;&#93;\ \&#40;&#40;
\*SubscriptBox&#91;\&#40;h\&#41;, \&#40;i, j\&#41;&#93; - 
\*SubscriptBox&#91;\&#40;h\&#41;, \&#40;i - 1, j\&#41;&#93;&#41;\&#41;\&#41;, \&#40;L\&#41;&#93;\&#41; - &#40;
   Subscript&#91;g, i - 1&#93; Subscript&#91;h, i, i - 1&#93;&#41;/L;
term2 &#61; term1 /. &#40;&#40;-Subscript&#91;x, -1 &#43; i&#93; &#43; Subscript&#91;x, i&#93;&#41;&#41; -&gt; 
    termDif;
term3 &#61; Collect&#91;term2, &#123;Subscript&#91;g, i&#93;, Subscript&#91;g, i - 1&#93;&#125;, 
  Simplify&#93;</code></pre> <p><img src="https://raw.githubusercontent.com/Shuvomoy/blogs/master/posts/Accelerated_methods_as_fixed_step_first_order_method.assets/image-20220111155941105.png" alt=image-20220111155941105  /></p> <p>Recall that, using &#40;Diff-x&#41; any &#40;SBFOM&#41; satisfying sequence will obey: </p> <div class=nonumber >\[x_{i+1}=x_{i}-\sum_{j=0}^{i-1}\frac{(h_{i+1,j}-h_{i,j})}{L}g_{j}-\frac{h_{i+1,i}}{L}g_{i}\quad \textrm{(Diff-x-2)}\]</div> <p>Note that &#40;Diff-x-2&#41; and &#40;SBFOM-A&#41; are in the same format now for a pattern matching. Comparing the terms part by part, we get the following recursive system for \(i\in [0:N-1]\) ​</p> \[ \begin{align*}\forall_{j\in[0:i-2]}\quad h_{i+1,j} & -h_{i,j}=\zeta_{i+1}\left(h_{i,j}-h_{i-1,j}\right)\\ h_{i+1,i-1}-h_{i,i-1} & =\zeta_{i+1}\left(h_{i,i-1}-1\right)\\ h_{i+1,i} & =\zeta_{i+1}+\eta_{i+1}+1. \end{align*} \] <p>with initial condition \(h_{1,k}=0\) if \(k<0\) and \(h_{0,k}=0\) for all \(k\). This system of equation gives us a way to compute \(\zeta,\eta\)​ from \(h\)​.</p> <h3 id=julia_code_to_construct_h_from_zeta_eta_and_back ><a href="#julia_code_to_construct_h_from_zeta_eta_and_back" class=header-anchor >Julia code to construct \(h\) from \(\{\zeta, \eta\}\) and back</a></h3> <p>The main system of equations is for this conversion process is: </p> \[ \begin{align*} & h\equiv\{h_{i,j}\}_{i\in[1:N],j\in[0:i-1]}\\ & \forall_{i\in[0:N-1]}\forall_{j\in[0:i-2]}\quad h_{i+1,j}-h_{i,j}=\zeta_{i+1}\left(h_{i,j}-h_{i-1,j}\right)\\ & \forall_{i\in[0:N-1]}\quad h_{i+1,i-1}-h_{i,i-1}=\zeta_{i+1}\left(h_{i,i-1}-1\right)\\ & \forall_{i\in[0:N-1]}\quad h_{i+1,i}=\zeta_{i+1}+\eta_{i+1}+1\\ & h_{1,j}=0,\textrm{ if }j<0\\ & \forall_{j\in[0:i-1]}\quad h_{0,j}=0. \end{align*} \] <h4 id=code_to_construct_h_from_zeta_eta ><a href="#code_to_construct_h_from_zeta_eta" class=header-anchor >Code to construct \(h\) from \(\{\zeta, \eta\}\)</a></h4> <p>Suppose we have \(\{\zeta, \eta\}\) and we want to construct \(h\) from that. So, the Julia code to do that is as follows:</p> <pre><code class=language-julia >## function to construct h from ζ, η

function construct_h_from_ζ_η&#40;N, L, ζ, η; solution_method &#61; :constraint&#41;

   # other option for solution_method is :penalty

   # time to construct model

   mod1 &#61; Model&#40;Gurobi.Optimizer&#41;

   @variable&#40;mod1, h&#91;i&#61;0:N, j&#61;-2:N&#93; &gt;&#61; 0&#41;

   # we are just interested in h&#91;i &#61; 1:N, j &#61; 0:i-1&#93;, rest should be set to zero

   for i in 0:N
      for j in -2:N
         if &#33;&#40;i &gt;&#61; 1 &amp;&amp; i &lt;&#61; N &amp;&amp; j &gt;&#61; 0 &amp;&amp; j &lt;&#61; i-1&#41;
            fix&#40;h&#91;i,j&#93;, 0.0; force &#61; true&#41;
         end
      end
   end

   if solution_method &#61;&#61; :constraint

      for i in 0:N-1
         for j in 0:i-2
            @constraint&#40;mod1, h&#91;i&#43;1,j&#93; - h&#91;i,j&#93; .&#61;&#61; ζ&#91;i&#43;1&#93;*&#40;h&#91;i,j&#93; - h&#91;i-1,j&#93;&#41; &#41;
         end
      end

      for i in 0:N-1
         @constraint&#40;mod1, h&#91;i&#43;1,i-1&#93; - h&#91;i,i-1&#93; .&#61;&#61; ζ&#91;i&#43;1&#93;*&#40;h&#91;i,i-1&#93; -1&#41; &#41;
      end

      for i in 0:N-1
         @constraint&#40;mod1, h&#91;i&#43;1,i&#93; .&#61;&#61; ζ&#91;i&#43;1&#93; &#43; η&#91;i&#43;1&#93; &#43; 1 &#41;
      end

      @objective&#40;mod1, Min, 0&#41;

   elseif solution_method &#61;&#61; :penalty

      term_1 &#61; @expression&#40;mod1, sum&#40; &#40;h&#91;i&#43;1,j&#93; - h&#91;i,j&#93; - ζ&#91;i&#43;1&#93;*&#40;h&#91;i,j&#93; - h&#91;i-1,j&#93;&#41;&#41;^2 for i in 0:N-1, j in 0:N-1 if j &lt;&#61; i-2&#41; &#41;

      term_2 &#61; @expression&#40;mod1, sum&#40; &#40;h&#91;i&#43;1,i-1&#93; - h&#91;i,i-1&#93; - ζ&#91;i&#43;1&#93;*&#40;h&#91;i,i-1&#93; -1&#41;&#41;^2 for i in 0:N-1&#41;&#41;

      term_3 &#61; @expression&#40;mod1, sum&#40; &#40;h&#91;i&#43;1,i&#93; - &#40;ζ&#91;i&#43;1&#93; &#43; η&#91;i&#43;1&#93; &#43; 1&#41; &#41;^2 for i in 0:N-1&#41; &#41;

      @objective&#40;mod1, Min, term_1 &#43; term_2 &#43; term_3&#41;

   end

   optimize&#33;&#40;mod1&#41;

   if termination_status&#40;mod1&#41; &#33;&#61; OPTIMAL
      @error &quot;termination status is not optimal&quot;
   end

   obj_val &#61; objective_value&#40;mod1&#41;

   @info &quot;Value of h for N&#61;&#36;&#40;N&#41; with fitting error &#61; &#36;&#40;obj_val&#41;&quot;

   h_star &#61; value.&#40;h&#41;

   # h_star_compact &#61; h&#91;i&#61;1:N, j &#61; 0:N-1 if j &lt;&#61; i-1&#93;
   #
   # @show h_star_compact

   return h_star

end</code></pre> <p>Let us test the function. First, we generate a specific \(\zeta, \eta\) to test for, which comes from OGM &#40;see below about more details about OGM&#41;. </p> <pre><code class=language-julia >## Load the packages

using OffsetArrays, Gurobi, JuMP, LinearAlgebra

N &#61; 5

# Generate θ for OGM

L &#61; 1

R &#61; 1

θ &#61; Dict&#123;Int64,Float64&#125;&#40;&#41;

θ&#91;0&#93; &#61; 1

for i in 1:N
   if i &lt;&#61; N-1
        θ&#91;i&#93; &#61; &#40;1&#43;sqrt&#40;1&#43;4*θ&#91;i-1&#93;^2&#41;&#41;/2
   elseif i &#61;&#61; N
       θ&#91;i&#93; &#61; &#40;1&#43;sqrt&#40;1&#43;8*θ&#91;i-1&#93;^2&#41;&#41;/2
   end
end

ζ_OGM &#61; OffsetVector&#40;zeros&#40;N&#41;, 1:N&#41;

for i in 0:N-1
   ζ_OGM&#91;i&#43;1&#93; &#61; &#40;θ&#91;i&#93;-1&#41;/θ&#91;i&#43;1&#93;
end

@show ζ_OGM

# output: 
# ζ_OGM &#61; &#91;0.0, 0.28175352512532087, 0.434042782780302, 0.5310638054044795, 0.4424791858537259&#93;

η_OGM &#61; OffsetVector&#40;zeros&#40;N&#41;, 1:N&#41;

for i in 0:N-1
   η_OGM&#91;i&#43;1&#93; &#61; θ&#91;i&#93;/θ&#91;i&#43;1&#93;
end

@show η_OGM

# output:
# η_OGM &#61; &#91;0.6180339887498948, 0.7376403052281875, 0.7977067398993897, 0.8345650247944008, 0.6352906827290474&#93;</code></pre> <p>Now let us test the function <code>construct_h_from_ζ_η</code>.</p> <pre><code class=language-julia >h_star_constraint &#61; construct_h_from_ζ_η&#40;N, L, ζ_OGM, η_OGM; solution_method &#61; :constraint&#41;

@show round.&#40;h_star_constraint&#91;1:N, 0:N-1&#93;, digits &#61; 5&#41;

# The output is:
# h_star_constraint&#91;1:N, 0:N-1&#93; &#61;
# &#91;
# 1.61803  0.0      0.0      0.0      0.0;
# 1.79217  2.01939  0.0      0.0      0.0;
# 1.86775  2.46185  2.23175  0.0      0.0;
# 1.90789  2.69683  2.88589  2.36563  0.0;
# 1.92565  2.8008   3.17533  2.96989  2.07777
# &#93;

h_star_penalty &#61; construct_h_from_ζ_η&#40;N, L, ζ_OGM, η_OGM; solution_method &#61; :penalty&#41;

@show round.&#40;h_star_penalty&#91;1:N, 0:N-1&#93;, digits &#61; 5&#41;

# The output is:
# h_star_penalty&#91;1:N, 0:N-1&#93; &#61;
# &#91;
# 1.61803  0.0      0.0      0.0      0.0
# 1.79217  2.01939  0.0      0.0      0.0
# 1.86775  2.46185  2.23175  0.0      0.0
# 1.90789  2.69683  2.88589  2.36563  0.0
# 1.92565  2.8008   3.17533  2.96989  2.07777
# &#93;

h_star &#61; h_star_penalty # we will use this for another test below</code></pre> <h4 id=code_to_construct_zeta_eta_from_h ><a href="#code_to_construct_zeta_eta_from_h" class=header-anchor >Code to construct \(\{\zeta, \eta\}\) from \(h\)</a></h4> <p>Now we consider the opposite direction. Now we want to construct \(\{\zeta, \eta\}\) from a given \(h\). The Julia code to do that is as follows:</p> <pre><code class=language-julia >function construct_ζ_η_from_h&#40;N, L, h; fix_ζ_η &#61; :true, ζ_ws &#61; ζ_OGM, η_ws &#61; η_OGM&#41;

   mod1 &#61; Model&#40;Gurobi.Optimizer&#41;

   @variable&#40;mod1, ζ&#91;i &#61; 1:N&#93;&#41;

   @variable&#40;mod1, η&#91;i &#61; 1:N&#93;&#41;

   if fix_ζ_η &#61;&#61; :true
     @info &quot;fixing  ζ and η to that of OGM to check if there are multiple solutions&quot;
     fix.&#40;ζ, ζ_ws; force&#61;true&#41;
     fix.&#40;η, η_ws; force &#61; true&#41;
  end

   term_1 &#61; @expression&#40;mod1, sum&#40; &#40;h&#91;i&#43;1,j&#93; - h&#91;i,j&#93; - ζ&#91;i&#43;1&#93;*&#40;h&#91;i,j&#93; - h&#91;i-1,j&#93;&#41;&#41;^2 for i in 0:N-1, j in 0:N-1 if j &lt;&#61; i-2&#41; &#41;

   term_2 &#61; @expression&#40;mod1, sum&#40; &#40; h&#91;i&#43;1,i-1&#93; - h&#91;i,i-1&#93; - ζ&#91;i&#43;1&#93;*&#40;h&#91;i,i-1&#93; -1&#41; &#41;^2 for i in 0:N-1&#41;&#41;

   term_3 &#61; @expression&#40;mod1, sum&#40; &#40;h&#91;i&#43;1,i&#93; - &#40;ζ&#91;i&#43;1&#93; &#43; η&#91;i&#43;1&#93; &#43; 1&#41; &#41;^2 for i in 0:N-1&#41; &#41;

   @objective&#40;mod1, Min, term_1 &#43; term_2 &#43; term_3&#41;

   optimize&#33;&#40;mod1&#41;

   if termination_status&#40;mod1&#41; &#33;&#61; OPTIMAL
      @error &quot;termination status is not optimal&quot;
   end

   obj_val &#61; objective_value&#40;mod1&#41;

   @info &quot;fitting error for N&#61;&#36;&#40;N&#41; to construct ζ, η from h &#61; &#36;&#40;obj_val&#41;&quot;

   ζ_star &#61; value.&#40;ζ&#41;

   η_star &#61; value.&#40;η&#41;

   return ζ_star, η_star

end</code></pre> <p>Let us now test this function. </p> <pre><code class=language-julia >ζ_star, η_star &#61; construct_ζ_η_from_h&#40;N, L, h_star; fix_ζ_η &#61; :false&#41;

# output: &#91; Info: fitting error for N&#61;5 to construct ζ, η from h &#61; -6.039613253960852e-14

@show ζ_star

# output: ζ_star &#61; &#91;6.352740751660148e-16, 0.2817535522830343, 0.43404278553274767, 0.5310638059557159, 0.442479185968013&#93;

@show η_star

# output: η_star &#61; &#91;0.6180340040827577, 0.7376402784557785, 0.7977067372415494, 0.8345650242736313, 0.6352906826136708&#93;</code></pre> <p>Let us compare now if the original \(\zeta, \eta\) from OGM matches this reconstructed.</p> <pre><code class=language-julia >## Compare with original ζ, η coming from OGM

@show &quot;difference between ζ_OGM and ζ_reconstructed is: &#36;&#40;norm&#40;ζ_star - ζ_OGM&#41;&#41;&quot;

# output: 
# &quot;difference between ζ_OGM and ζ_reconstructed is: &#36;&#40;norm&#40;ζ_star - ζ_OGM&#41;&#41;&quot; &#61; &quot;difference between ζ_OGM and ζ_reconstructed is: 2.7302642325329647e-8&quot;

@show &quot;difference between ζ_OGM and ζ_reconstructed is: &#36;&#40;norm&#40;η_star - η_OGM&#41;&#41;&quot;

# output:
# &quot;difference between ζ_OGM and ζ_reconstructed is: &#36;&#40;norm&#40;η_star - η_OGM&#41;&#41;&quot; &#61; &quot;difference between ζ_OGM and ζ_reconstructed is: 3.0971070252469905e-8&quot;</code></pre> <h2 id=converting_between_auxiliary-format_form_and_momentum-form ><a href="#converting_between_auxiliary-format_form_and_momentum-form" class=header-anchor >Converting between auxiliary-format form and momentum-form</a></h2> <p>Recall that the momentum-form is written as:</p> \[ \begin{align*} \begin{array}{ll} y_{i+1} & =x_{i}-\frac{1}{L}\nabla f(x_{i}), \quad (i)\\ x_{i+1} & =y_{i+1}+\zeta_{i+1}(y_{i+1}-y_{i})+\eta_{i+1}(y_{i+1}-x_{i}) \quad (ii), \end{array}\quad(\textrm{MomentumForm)} \end{align*} \] <p>Another common format that usually appears in proofs is the so-called auxiliary-format form:</p> \[ \begin{align*} \begin{array}{ll} x_{i}=(1-\delta_{i})y_{i}+\delta_{i}z_{i},\quad(i)\\ y_{i+1}=x_{i}-\frac{1}{L}\nabla f(x_{i}),\quad(ii) \\ z_{i+1}=z_{i}+\gamma_{i}(y_{i+1}-x_{i}).\quad(iii) \end{array}\quad(\textrm{AuxForm)}\end{align*} \] <p>Now, the iterate \(x_{i+1}\) would be: </p> \[ \begin{align*} x_{i+1} & =(1-\delta_{i+1})y_{i+1}+\delta_{i+1}z_{i+1} \\ & =(1-\delta_{i+1})y_{i+1}+\delta_{i+1}\left(z_{i}+\gamma_{i}(y_{i+1}-x_{i})\right)\\ & =(1-\delta_{i+1})y_{i+1}+\delta_{i+1}\left(\frac{1}{\delta_{i}}x_{i}+\left(1-\frac{1}{\delta_{i}}\right)y_{i}+\gamma_{i}(y_{i+1}-x_{i})\right)\\ & =y_{i+1}+\left(\frac{\delta_{i+1}}{\delta_{i}}-\delta_{i+1}\right)\left(y_{i+1}-y_{i}\right)+\left(\gamma_{i}\delta_{i+1}-\frac{\delta_{i+1}}{\delta_{i}}\right)\left(y_{i+1}-x_{i}\right), \quad (\textrm{SimpX}) \end{align*} \] <p>where in the third line we have used the equation</p> \[ z_{i}=\frac{1}{\delta_{i}}x_{i}+\left(1-\frac{1}{\delta_{i}}\right)y_{i}. \] <p>that comes from &#40;AuxForm&#41;&#40;i&#41;. Comparing &#40;SimpX&#41; with &#40;MomentumForm&#41;:</p> \[ \begin{align*} \zeta_{i+1} & =\delta_{i+1}\left(\frac{1}{\delta_{i}}-1\right),\\ \eta_{i+1} & =\delta_{i+1}\left(\gamma_{i}-\frac{1}{\delta_{i}}\right). \end{align*} \] <p>Given \(\zeta, \eta\) we can compute \(\delta, \gamma\) as follows. Define: \(a_i = 1/\delta_i\), then solve the linear system of equations with variables \(a_i, \gamma_i\): </p> \[ \begin{align*} & \zeta_{i+1}a_{i+i}=a_{i}-1, \\ & \eta_{i+1}a_{i+1}=\gamma_{i}-a_{i}. \end{align*} \] <p>Then we have \(\gamma_i\) we compute \(\delta_i\) by using \(\delta_i = 1/a_i\). </p> <p><strong>Mathematica code.</strong></p> <pre><code class=language-julia >CollectWRTVarList&#91;expr_, vars_List&#93; :&#61; 
  Expand&#91;Simplify&#91;
     expr /. Flatten&#91;
       Solve&#91;# &#61;&#61; ToString@#, First@Variables@#&#93; &amp; /@ vars&#93;&#93;, 
    Alternatives @@ ToString /@ vars&#93; /. 
   Thread&#91;ToString /@ vars -&gt; vars&#93;;
term1 &#61; CollectWRTVarList&#91;
    Subscript&#91;y, 
      1 &#43; i&#93; &#40;1 - Subscript&#91;\&#91;Delta&#93;, 
        1 &#43; i&#93;&#41; &#43; &#40;&#40;-Subscript&#91;x, i&#93; &#43; Subscript&#91;y, 
           1 &#43; i&#93;&#41; Subscript&#91;\&#91;Gamma&#93;, i&#93; &#43; 
        Subscript&#91;y, i&#93; &#40;1 - Subscript&#91;inv\&#91;Delta&#93;, i&#93;&#41; &#43; 
        Subscript&#91;x, i&#93; Subscript&#91;inv\&#91;Delta&#93;, i&#93;&#41; Subscript&#91;\&#91;Delta&#93;,
       1 &#43; i&#93;, &#123;Subscript&#91;y, 1 &#43; i&#93; - Subscript&#91;y, i&#93;, 
     Subscript&#91;y, 1 &#43; i&#93; - Subscript&#91;x, 
      i&#93;&#125;&#93; /. &#123;&#40;-Subscript&#91;x, i&#93; &#43; Subscript&#91;y, 1 &#43; i&#93;&#41; -&gt; 
     fact1, &#40;-Subscript&#91;y, i&#93; &#43; Subscript&#91;y, 1 &#43; i&#93;&#41; -&gt; fact2&#125;;
termFinal &#61; 
 Collect&#91;term1, &#123;fact1, 
    fact2&#125;&#93; /. &#123;fact1 -&gt; &#40;-Subscript&#91;x, i&#93; &#43; Subscript&#91;y, 1 &#43; i&#93;&#41;, 
   fact2 -&gt; &#40;-Subscript&#91;y, i&#93; &#43; Subscript&#91;y, 1 &#43; i&#93;&#41;, 
   Subscript&#91;inv\&#91;Delta&#93;, i&#93; -&gt; &#40;1/Subscript&#91;\&#91;Delta&#93;, i&#93;&#41;, 
   Linv -&gt; &#40;1/L&#41;&#125;</code></pre> <h2 id=example_1_fista ><a href="#example_1_fista" class=header-anchor >Example 1. FISTA</a></h2> <p>FISTA in momentum format is</p> \[ \begin{aligned} & x_{0}=y_{0},\quad(i)\\ & y_{i+1}=x_{i}-\frac{1}{L}\nabla f(x_{i})-\frac{1}{L}h^{\prime}(y_{i+1}),\quad i\in[0:N-1],\quad(ii)\\ & x_{i+1}=y_{i+1}+\zeta_{i+1}(y_{i+1}-y_{i})+\eta_{i+1}(y_{i+1}-x_{i}),\quad i\in[0:N-1].\quad(iii) \end{aligned} \] <p>FISTA in auxiliary iterate format:</p> \[ \begin{eqnarray*} & & z_{0}=x_{0}=y_{0},\quad(i)\\ & & x_{i}=(1-\delta_{i})y_{i}+\delta_{i}z_{i},\quad(ii)\\ & & y_{i+1}=x_{i}-\frac{1}{L}\nabla f(x_{i})-\frac{1}{L}h^{\prime}(y_{i+1}),\quad(iii)\\ & & z_{i+1}=z_{i}+\gamma_{i}(y_{i+1}-x_{i}).\quad(iv) \end{eqnarray*} \] <p>From auxiliary format &#40;ii&#41; we have </p> \[ z_{i}=\frac{1}{\delta_{i}}x_{i}+\left(1-\frac{1}{\delta_{i}}\right)y_{i} \] <p>At the next iteration we have: </p> \[ \begin{align*} x_{i+1} & =(1-\delta_{i+1})y_{i+1}+\delta_{i+1}z_{i+1}\\ & =(1-\delta_{i+1})y_{i+1}+\delta_{i+1}\left(z_{i}+\gamma_{i}(y_{i+1}-x_{i})\right)\\ & =(1-\delta_{i+1})y_{i+1}+\delta_{i+1}\left(\frac{1}{\delta_{i}}x_{i}+\left(1-\frac{1}{\delta_{i}}\right)y_{i}+\gamma_{i}(y_{i+1}-x_{i})\right)\\ & =y_{i+1}+\left(\frac{\delta_{i+1}}{\delta_{i}}-\delta_{i+1}\right)\left(y_{i+1}-y_{i}\right)+\left(\gamma_{i}\delta_{i+1}-\frac{\delta_{i+1}}{\delta_{i}}\right)\left(y_{i+1}-x_{i}\right). \end{align*} \] <p>By pattern-matching we have the follwoing relationship: </p> \[ \begin{align*} \zeta_{i+1} & =\delta_{i+1}\left(\frac{1}{\delta_{i}}-1\right),\\ \eta_{i+1} & =\delta_{i+1}\left(\gamma_{i}-\frac{1}{\delta_{i}}\right). \end{align*} \] <h2 id=example_2_ogm ><a href="#example_2_ogm" class=header-anchor >Example 2. OGM</a></h2> <p>As our example, we consider the Optimized Gradient Method &#40;OGM&#41; due to Kim and Fessler. For a \(L\)-smooth convex function \(f\), \(x_{0}\in\mathbf{R}^{d},\theta_{0}=1,\) the algorithm is defined in its <em>auxiliary form</em> as</p> \[\begin{array}{ll} y_{i+1} & =x_{i}-\frac{1}{L}\nabla f(x_{i})\\ z_{i+1} & =z_{i}-\frac{2\theta_{i}}{L}\nabla f(x_{i})\\ x_{i+1} & =\left(1-\frac{1}{\theta_{i+1}}\right)y_{i+1}+\frac{1}{\theta_{i+1}}z_{i+1}, \end{array}\quad(\textrm{OGM)}\] <p>​ where \(i\in\{0,1,\ldots,N-1\}\)​. </p> <p>First, note that in &#40;OGM&#41;, gradient is evaluated at \(x_{i}\)​ iterates, so we will try to remove \(z_{i}\)​ iterates from &#40;OGM&#41;, and write the last iterate as terms involving \(y_{i+1},y_{i},\)​ and \(x_{i}\)​. To that goal, we will write, \(z_{i+1}\)​ completely using \(y_{i},x_{i},\)​ and \(y_{i+1}\)​. From, the first iteration of &#40;OGM&#41;, </p> \[\frac{1}{L}\nabla f(x_{i})=x_{i}-y_{i+1},\quad(1)\] <p>​ and putting &#40;1&#41; in the second iterate of &#40;OGM&#41;, we have </p> \[\begin{align*} z_{i+1} & =z_{i}-\frac{2\theta_{i}}{L}\nabla f(x_{i})\\ & =z_{i}-(2\theta_{i})(x_{i}-y_{i+1})\\ & =z_{i}-2\theta_{i}x_{i}+2\theta_{i}y_{i+1}\quad(2).\end{align*}\] <p>​ The third iterate of &#40;OGM&#41; for index \(i\)​ will give:</p> <pre><code class=language-julia >ClearAll&#91;&quot;Global&#96;*&quot;&#93;;

Solve&#91;y&#91;i&#93; &#40;1 - 1/\&#91;Theta&#93;&#91;i&#93;&#41; &#43; z&#91;i&#93;/\&#91;Theta&#93;&#91;i&#93; &#61;&#61; x&#91;i&#93;, z&#91;i&#93;&#93;
&#40;*Out&#91;&#93; &#61; &#123;&#123;z&#91;i&#93;\&#91;Rule&#93;y&#91;i&#93;&#43;x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;-y&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;&#125;&#125;*&#41;
Collect&#91;y&#91;i&#93; &#43; x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93; - y&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;, &#123;x&#91;i&#93;, y&#91;i&#93;&#125;&#93;
&#40;*Out&#91;&#93; &#61; y&#91;i&#93; &#40;1-\&#91;Theta&#93;&#91;i&#93;&#41;&#43;x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;*&#41;</code></pre> \[\begin{align*} x_{i} & =\left(1-\frac{1}{\theta_{i}}\right)y_{i}+\frac{1}{\theta_{i}}z_{i}\\ \Leftrightarrow z_{i} & =(1-\theta_{i})y_{i}+\theta_{i}x_{i},\end{align*}\] <p>​ and putting that in &#40;2&#41;, we get:</p> <pre><code class=language-julia >z&#91;i&#93; - 2 \&#91;Theta&#93;&#91;i&#93; x&#91;i&#93; &#43; 2 \&#91;Theta&#93;&#91;i&#93; y&#91;i &#43; 1&#93; /. 
 z&#91;i&#93; -&gt; y&#91;i&#93; &#40;1 - \&#91;Theta&#93;&#91;i&#93;&#41; &#43; x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;
&#40;*Out&#91;&#93; &#61; y&#91;i&#93; &#40;1-\&#91;Theta&#93;&#91;i&#93;&#41;-x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;&#43;2 y&#91;1&#43;i&#93; \&#91;Theta&#93;&#91;i&#93;*&#41;</code></pre> \[\begin{align*} z_{i+1} & =z_{i}-2\theta_{i}x_{i}+2\theta_{i}y_{i+1}\\ & =(1-\theta_{i})y_{i}-\theta_{i}x_{i}+2\theta_{i}y_{i+1}\quad(3),\end{align*}\] <p>​ and putting &#40;3&#41; into the third iterate of &#40;OGM&#41;, we get</p> <pre><code class=language-julia >&#40;*This code will collect terms with a specific patterns*&#41;
&#40;*Caution all the terms have to be scalrs, does not work with 
table term such x&#91;i&#93; etc, but works with xi and so on*&#41;
CollectWRTVarList&#91;expr_, vars_List&#93; :&#61; 
  Expand&#91;Simplify&#91;
     expr /. Flatten&#91;
       Solve&#91;# &#61;&#61; ToString@#, First@Variables@#&#93; &amp; /@ vars&#93;&#93;, 
    Alternatives @@ ToString /@ vars&#93; /. 
   Thread&#91;ToString /@ vars -&gt; vars&#93;;

term &#61; &#40;1 - 1/\&#91;Theta&#93;&#91;i &#43; 1&#93;&#41; y&#91;i &#43; 1&#93; &#43; 
     1/\&#91;Theta&#93;&#91;i &#43; 1&#93; z&#91;i &#43; 1&#93; /. 
    z&#91;i &#43; 1&#93; -&gt; 
     y&#91;i&#93; &#40;1 - \&#91;Theta&#93;&#91;i&#93;&#41; - x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93; &#43; 
      2 y&#91;1 &#43; i&#93; \&#91;Theta&#93;&#91;i&#93; // Simplify;
&#40;*Out&#91;&#93; &#61; &#40;-y&#91;i&#93; &#40;-1&#43;\&#91;Theta&#93;&#91;i&#93;&#41;-x&#91;i&#93; \&#91;Theta&#93;&#91;i&#93;&#43;y&#91;1&#43;i&#93; &#40;-1&#43;2 \
\&#91;Theta&#93;&#91;i&#93;&#43;\&#91;Theta&#93;&#91;1&#43;i&#93;&#41;&#41;/\&#91;Theta&#93;&#91;1&#43;i&#93;*&#41;

CollectWRTVarList&#91;
  term, &#123;y&#91;i &#43; 1&#93; - y&#91;i&#93;, &#123;y&#91;i &#43; 1&#93; - x&#91;i&#93;&#125;&#125;&#93; /. &#123;-y&#91;i&#93; &#43; y&#91;1 &#43; i&#93; -&gt; 
   t1, -x&#91;i&#93; &#43; y&#91;1 &#43; i&#93; -&gt; t2 &#125;
&#40;*Out&#91;&#93; &#61; &#123;y&#91;1&#43;i&#93;-t1/\&#91;Theta&#93;&#91;1&#43;i&#93;&#43;&#40;t1 \&#91;Theta&#93;&#91;i&#93;&#41;/\&#91;Theta&#93;&#91;1&#43;i&#93;&#43;&#40;t2 \
\&#91;Theta&#93;&#91;i&#93;&#41;/\&#91;Theta&#93;&#91;1&#43;i&#93;&#125;*&#41;

Collect&#91;y&#91;1 &#43; i&#93; - t1/\&#91;Theta&#93;&#91;1 &#43; i&#93; &#43; &#40;
   t1 \&#91;Theta&#93;&#91;i&#93;&#41;/\&#91;Theta&#93;&#91;1 &#43; i&#93; &#43; &#40;
   t2 \&#91;Theta&#93;&#91;i&#93;&#41;/\&#91;Theta&#93;&#91;1 &#43; i&#93;, &#123;t1, t2&#125;, 
  Simplify&#93; /. &#123;t1 -&gt; -y&#91;i&#93; &#43; y&#91;1 &#43; i&#93;, t2 -&gt; -x&#91;i&#93; &#43; y&#91;1 &#43; i&#93;&#125;
&#40;*Out&#91;&#93; &#61; y&#91;1&#43;i&#93;&#43;&#40;&#40;-y&#91;i&#93;&#43;y&#91;1&#43;i&#93;&#41; \
&#40;-1&#43;\&#91;Theta&#93;&#91;i&#93;&#41;&#41;/\&#91;Theta&#93;&#91;1&#43;i&#93;&#43;&#40;&#40;-x&#91;i&#93;&#43;y&#91;1&#43;i&#93;&#41; \
\&#91;Theta&#93;&#91;i&#93;&#41;/\&#91;Theta&#93;&#91;1&#43;i&#93;*&#41;</code></pre> \[\begin{align*} x_{i+1} & =\left(1-\frac{1}{\theta_{i+1}}\right)y_{i+1}+\frac{1}{\theta_{i+1}}z_{i+1}\\ = & y_{i+1}+\frac{\theta_{i}-1}{\theta_{i+1}}(y_{i+1}-y_{i})+\frac{\theta_{i}}{\theta_{i+1}}(y_{i+1}-x_{i}).\end{align*}\] <p>So, we have the following &quot;<em>momentum form</em>&quot; of &#40;OGM&#41;: <div class=nonumber >\[\begin{array}{ll} y_{i+1} & =x_{i}-\frac{1}{L}\nabla f(x_{i})\\ x_{i+1} & =y_{i+1}+\frac{\theta_{i}-1}{\theta_{i+1}}(y_{i+1}-y_{i})+\frac{\theta_{i}}{\theta_{i+1}}(y_{i+1}-x_{i}), \end{array}\quad(\textrm{MomentumOGM)}\]</div>​ which we show to be equivalent to &#40;SBFOM&#41;. To show that &#40;MomentumOGM&#41; is in the form &#40;SBFOM&#41;, we put, the iterative form \(y_{+1}\) and \(y_{i}\) in terms of the \(x\) iterates in the second iterate. For simplification purpose, denote \(g_{i}=\nabla f(x_{i})\). We get:</p> <pre><code class=language-julia >Subscript&#91;y, 1 &#43; i&#93; &#61; Subscript&#91;x, i&#93; - Subscript&#91;g, i&#93;/L;

Subscript&#91;y, i&#93; &#61; Subscript&#91;x, i - 1&#93; - Subscript&#91;g, i - 1&#93;/L;

Subscript&#91;x, i &#43; 1&#93; &#61; 
  Subscript&#91;y, 
   i &#43; 1&#93; &#43; &#40;&#40;Subscript&#91;\&#91;Theta&#93;, i&#93; - 1&#41; &#40;Subscript&#91;y, i &#43; 1&#93; - 
      Subscript&#91;y, i&#93;&#41;&#41;/Subscript&#91;\&#91;Theta&#93;, i &#43; 1&#93; &#43; &#40;
   Subscript&#91;\&#91;Theta&#93;, i&#93; &#40;Subscript&#91;y, i &#43; 1&#93; - Subscript&#91;x, i&#93;&#41;&#41;/
   Subscript&#91;\&#91;Theta&#93;, i &#43; 1&#93;;
   
Collect&#91;Subscript&#91;x, 
 i &#43; 1&#93;, &#123;Subscript&#91;x, i&#93;, Subscript&#91;x, i&#93; - Subscript&#91;x, i - 1&#93;, 
  Subscript&#91;g, i&#93;&#125;, Simplify&#93;
&#40;*Output&#91;&#93; &#61; Subscript&#91;x, i&#93;&#43;&#40;Subscript&#91;g, -1&#43;i&#93; &#40;-1&#43;Subscript&#91;\ \&#91;Theta&#93;, i&#93;&#41;&#41;/&#40;L Subscript&#91;\&#91;Theta&#93;, 1&#43;i&#93;&#41;&#43;&#40;&#40;-Subscript&#91;x, \ -1&#43;i&#93;&#43;Subscript&#91;x, i&#93;&#41; &#40;-1&#43;Subscript&#91;\&#91;Theta&#93;, \ i&#93;&#41;&#41;/Subscript&#91;\&#91;Theta&#93;, 1&#43;i&#93;-&#40;Subscript&#91;g, i&#93; &#40;-1&#43;2 Subscript&#91;\ \&#91;Theta&#93;, i&#93;&#43;Subscript&#91;\&#91;Theta&#93;, 1&#43;i&#93;&#41;&#41;/&#40;L Subscript&#91;\&#91;Theta&#93;, 1&#43;i&#93;&#41;*&#41;</code></pre> <div class=nonumber >\[x_{i+1}=x_{i}+\frac{\left(\theta_{i}-1\right)\left(x_{i}-x_{i-1}\right)}{\theta_{i+1}}+\frac{g_{i-1}\left(\theta_{i}-1\right)}{L\theta_{i+1}}-\frac{g_{i}\left(2\theta_{i}+\theta_{i+1}-1\right)}{L\theta_{i+1}}\quad(1)\]</div> <p>Now from &#40;SBFOM&#41;:</p> \[\begin{align*} x_{i} & =x_{0}-\sum_{j=0}^{i-1}\frac{h_{i,j}}{L}g_{j},\\ x_{i-1} & =x_{0}-\sum_{j=0}^{i-2}\frac{h_{i-1,j}}{L}g_{j},\end{align*}\] <p>​ which gives </p> \[\begin{align*} x_{i}-x_{i-1} & =-\sum_{j=0}^{i-2}\frac{(-h_{i-1,j}+h_{i,j})}{L}g_{j}-\frac{h_{i,i-1}}{L}g_{i-1}\quad(2)\end{align*}\] <p>​​ and putting this in &#40;1&#41; and then simplifying we get:</p> <pre><code class=language-julia >&#40;*x&#91;i&#43;1&#93;&#61;*&#41;
term1 &#61; x&#91;i&#93; &#43; &#40;g&#91;-1 &#43; i&#93; &#40;-1 &#43; \&#91;Theta&#93;&#91;i&#93;&#41;&#41;/&#40;
   L \&#91;Theta&#93;&#91;
     1 &#43; i&#93;&#41; &#43; &#40;&#40;-x&#91;-1 &#43; i&#93; &#43; x&#91;i&#93;&#41; &#40;-1 &#43; \&#91;Theta&#93;&#91;i&#93;&#41;&#41;/\&#91;Theta&#93;&#91;
    1 &#43; i&#93; - &#40;g&#91;i&#93; &#40;-1 &#43; 2 \&#91;Theta&#93;&#91;i&#93; &#43; \&#91;Theta&#93;&#91;1 &#43; i&#93;&#41;&#41;/&#40;
   L \&#91;Theta&#93;&#91;1 &#43; i&#93;&#41;;
   
&#40;*x&#91;i&#93;-x&#91;i-1&#93;&#61;*&#41;
termDif &#61; &#40;-h&#91;i, i - 1&#93;/L g&#91;i - 1&#93; - \&#33;\&#40;
\*UnderoverscriptBox&#91;\&#40;\&#91;Sum&#93;\&#41;, \&#40;j &#61; 0\&#41;, \&#40;i - 2\&#41;&#93;\&#40;
\*FractionBox&#91;\&#40;&#40;\&#40;-h&#91;i - 1, j&#93;\&#41; &#43; h&#91;i, j&#93;&#41;\&#41;, \&#40;L\&#41;&#93; g&#91;j&#93;\&#41;\&#41;&#41;;

term2 &#61; term1 /. &#40;-x&#91;-1 &#43; i&#93; &#43; x&#91;i&#93;&#41; -&gt; termDif;

term3 &#61; Collect&#91;term2, &#123;g&#91;i&#93;, g&#91;i - 1&#93;&#125;, Simplify&#93;;

term4 &#61; term3 /. &#123;h_&#91;a_&#93; -&gt; Subscript&#91;h, a&#93;, 
   h&#91;i, j&#93; -&gt; Subscript&#91;h, i, j&#93;, 
   h&#91;-1 &#43; i, j&#93; -&gt; Subscript&#91;h, i - 1, j&#93;, 
   h&#91;i, -1 &#43; i&#93; -&gt; Subscript&#91;h, i, i - 1&#93;&#125;
&#40;*term4&#61;Subscript&#91;x, i&#93;-&#40;Subscript&#91;g, i&#93; &#40;-1&#43;2 Subscript&#91;\&#91;Theta&#93;, \
i&#93;&#43;Subscript&#91;\&#91;Theta&#93;, 1&#43;i&#93;&#41;&#41;/&#40;L Subscript&#91;\&#91;Theta&#93;, \
1&#43;i&#93;&#41;-&#40;Subscript&#91;g, -1&#43;i&#93; &#40;-1&#43;Subscript&#91;\&#91;Theta&#93;, i&#93;&#41; \
&#40;-1&#43;Subscript&#91;h, i,-1&#43;i&#93;&#41;&#41;/&#40;L Subscript&#91;\&#91;Theta&#93;, \
1&#43;i&#93;&#41;-&#40;&#40;-1&#43;Subscript&#91;\&#91;Theta&#93;, i&#93;&#41; \&#33;\&#40;
\*UnderoverscriptBox&#91;\&#40;\&#91;Sum&#93;\&#41;, \&#40;j &#61; 0\&#41;, \&#40;\&#40;-2\&#41; &#43; i\&#41;&#93;
\*FractionBox&#91;\&#40;
\*SubscriptBox&#91;\&#40;g\&#41;, \&#40;j\&#41;&#93;\ \&#40;&#40;\&#40;-
\*SubscriptBox&#91;\&#40;h\&#41;, \&#40;\&#40;-1\&#41; &#43; i, j\&#41;&#93;\&#41; &#43; 
\*SubscriptBox&#91;\&#40;h\&#41;, \&#40;i, 
     j\&#41;&#93;&#41;\&#41;\&#41;, \&#40;L\&#41;&#93;\&#41;&#41;/Subscript&#91;\&#91;Theta&#93;, 1&#43;i&#93;*&#41;</code></pre> \[\begin{align*} x_{i+1} & =x_{i}-\frac{\left(\theta_{i}-1\right)}{\theta_{i+1}}\sum_{j=0}^{i-2}\frac{\left(h_{i,j}-h_{i-1,j}\right)}{L}g_{j}\\ & -\frac{\left(\theta_{i}-1\right)\left(h_{i,i-1}-1\right)}{L\theta_{i+1}}g_{i-1}-\frac{\left(2\theta_{i}+\theta_{i+1}-1\right)}{L\theta_{i+1}}g_{i}.\quad(\textrm{SBFOM-OGM})\end{align*}\] <p>​ Recall that, using &#40;2&#41; any &#40;SBFOM&#41; satisfying sequence will obey: </p> \[x_{i+1}=x_{i}-\sum_{j=0}^{i-1}\frac{(h_{i+1,j}-h_{i,j})}{L}g_{j}-\frac{h_{i+1,i}}{L}g_{i}\quad(3)\] <p>​ Note that &#40;3&#41; and &#40;SBFOM-OGM&#41; are in the same format now for a pattern matching. Comparing the terms part by part, we get the following recursive system: </p> \[\begin{align*} \forall_{j\in[0:i-2]}\quad h_{i+1,j} & -h_{i,j}=\frac{\left(\theta_{i}-1\right)}{\theta_{i+1}}\left(h_{i,j}-h_{i-1,j}\right)\\ h_{i+1,i-1}-h_{i,i-1} & =\frac{\left(\theta_{i}-1\right)\left(h_{i,i-1}-1\right)}{\theta_{i+1}}\\ h_{i+1,i} & =\frac{\left(2\theta_{i}+\theta_{i+1}-1\right)}{\theta_{i+1}},\end{align*}\] <p>​ with initial condition \(h_{1,j}=0\)​ for \(j<0\)​ and \(h_{0,j}=0\)​ for all \(j\)​.</p> <div class=page-foot > <div class=copyright > &copy; Shuvomoy Das Gupta. Last modified: May 19, 2024. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> </div> <script src="/blogs/libs/katex/katex.min.js"></script> <script src="/blogs/libs/katex/auto-render.min.js"></script> <script>renderMathInElement(document.body)</script> <script src="/blogs/libs/highlight/highlight.pack.js"></script> <script>hljs.initHighlightingOnLoad();hljs.configure({tabReplace: ' '});</script>